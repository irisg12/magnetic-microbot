% 10/27/24 Version

% Uses map and image coordinates generated in Python
% (microbot_image_processing.py) to run the A* algorithm and find the
% fastest path to a user-chosen target. Sends this string of directions to
% Arduino

clear;
close all;
% Define the serial port and baud rate
% pins should be in top right corner of board
ARD_ON = 1; % turns arduino code on/off for checking functionality of MATLAB code only
if ARD_ON == 1
    serialPort = "COM6"; % must change depending on the port
    baudRate = 9600;
    arduino1 = serialport(serialPort, baudRate);
    configureTerminator(arduino1, "LF");
    flush(arduino1); % Clear the serial port buffer
end

% runs the image processing python file, returning map array, start
% coordinates, and scale factor to scale the image
mmbot_video_processing_7x7;
map = double(map);
details(map);
SF = double(SF); 
% initalizes number of rows and columns on the PCB
MAX_X = YTRACES; 
MAX_Y = XTRACES;
open = [];
closed = []; 

% opens the cropped field picture to display the path
figure;
imshow(squared);
hold on;
if magnet_x_idx > 0
    plot((magnet_x_idx-.5)*SF, (magnet_y_idx-.5)*SF, "g."); % pass scale factor
end

xlabel('Verify the Magnet position using the Left Mouse button','Color','black');
but=0;
while (but ~= 1) % Repeat until the Left button is not clicked
    [xval,yval,but]=ginput(1);
end
xval=floor(xval/SF)+1;
yval=floor(yval/SF)+1;
xStart=yval;% X Coordinate of the Target
yStart=xval;% Y Coordinate of the Target
% sets current node to start
xNode = xStart;
yNode = yStart;
plot((yStart-.5)*SF, (xStart-.5)*SF, "gx"); % pass scale factor

xlabel('Select the Target using the Left Mouse button','Color','black');
but=0;
while (but ~= 1) % Repeat until the Left button is not clicked
    [xval,yval,but]=ginput(1);
end
xval=floor(xval/SF)+1;
yval=floor(yval/SF)+1;
xTarget=yval;% X Coordinate of the Target
yTarget=xval;% Y Coordinate of the Target

k=1; % Dummy counter
% adds all obstacle pixels to the list of "searched" pixels
for i=1:MAX_X
    for j=1:MAX_Y
        if(map(i,j) == -1)
            closed(k,1)=i; 
            closed(k,2)=j; 
            k=k+1;
        end
    end
end
CLOSED_COUNT=size(closed,1);

% initializes pathfinding parameters
OPEN_COUNT=1;
path_cost=0;
goal_distance=distance(xNode,yNode,xTarget,yTarget);
open(OPEN_COUNT,:)=insert_open(xNode,yNode,xNode,yNode,path_cost,goal_distance,goal_distance);
open(OPEN_COUNT,1)=0;
CLOSED_COUNT=CLOSED_COUNT+1;
closed(CLOSED_COUNT,1)=xNode;
closed(CLOSED_COUNT,2)=yNode;
NoPath=1;

while((xNode ~= xTarget || yNode ~= yTarget) && NoPath == 1)
 exp_array=expand_array(xNode,yNode,path_cost,xTarget,yTarget,closed,MAX_X,MAX_Y);
 exp_count=size(exp_array,1);
 %UPDATE LIST OPEN WITH THE SUCCESSOR NODES
 %OPEN LIST FORMAT
 %--------------------------------------------------------------------------
 %IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
 %--------------------------------------------------------------------------
 %EXPANDED ARRAY FORMAT
 %--------------------------------
 %|X val |Y val ||h(n) |g(n)|f(n)|
 %--------------------------------
 for i=1:exp_count
    flag=0;
    for j=1:OPEN_COUNT
        if(exp_array(i,1) == open(j,2) && exp_array(i,2) == open(j,3) )
            open(j,8)=min(open(j,8),exp_array(i,5)); 
            if open(j,8)== exp_array(i,5)
                % UPDATE PARENTS,gn,hn
                open(j,4)=xNode;
                open(j,5)=yNode;
                open(j,6)=exp_array(i,3);
                open(j,7)=exp_array(i,4);
            end % End of minimum fn check
            flag=1;
        end %End of node check
%         if flag == 1
%             break;
    end %End of j for
    if flag == 0
        OPEN_COUNT = OPEN_COUNT+1;
        open(OPEN_COUNT,:)=insert_open(exp_array(i,1),exp_array(i,2),xNode,yNode,exp_array(i,3),exp_array(i,4),exp_array(i,5));
    end %End of insert new element into the OPEN list
 end 

 % Find out the node with the smallest fn 
  index_min_node = min_fn(open,OPEN_COUNT,xTarget,yTarget);
  if (index_min_node ~= -1)    
   % Set xNode and yNode to the node with minimum fn
   xNode=open(index_min_node,2);
   yNode=open(index_min_node,3);
   path_cost=open(index_min_node,6);% Update the cost of reaching the parent node
  % Move the Node to list CLOSED
  CLOSED_COUNT=CLOSED_COUNT+1;
  closed(CLOSED_COUNT,1)=xNode;
  closed(CLOSED_COUNT,2)=yNode;
  open(index_min_node,1)=0;
  else
      % No path exists to the target
      NoPath=0;% Exits the loop 
  end 
end 

% Once algorithm has run, the optimal path is generated by starting of at the
% last node(if it is the target node) and then identifying its parent node
% until it reaches the start node.
i=size(closed,1);
Optimal_path=[];
xval=closed(i,1);
yval=closed(i,2);
i=1;
% adds point to optimal path
Optimal_path(i,1)=xval;
Optimal_path(i,2)=yval;
i=i+1;
if ( (xval == xTarget) && (yval == yTarget))
    inode=0;
   % Traverse OPEN and determine the parent nodes
   parent_x=open(node_index(open,xval,yval),4); % node_index returns the index of the node
   parent_y=open(node_index(open,xval,yval),5);
   
   while( parent_x ~= xStart || parent_y ~= yStart)
           Optimal_path(i,1) = parent_x;
           Optimal_path(i,2) = parent_y;
           %Get the grandparent nodes
           inode=node_index(open,parent_x,parent_y);
           parent_x=open(inode,4); % node_index returns the index of the node
           parent_y=open(inode,5);
           i=i+1;
   end 
   Optimal_path(i,1) = xStart;
   Optimal_path(i,2) = yStart;
 
 xlabel('');
 imshow(squared);
 hold on;
 % Plots the optimal path
 plot(SF*(Optimal_path(:,2)-.5),SF*(Optimal_path(:,1)-.5), "LineWidth", 4, "Color", [0.55, 0.2, 0.6]);
else % If final attempted node was not the target
 pause(1);
 h=msgbox('No path exists to the Target!');
 uiwait(h,5);
end

% Write data to the Arduino
pause(.5);
%disp(readline(arduino))
j = 1; % note: x and y are switched coordinates 
if ARD_ON == 1
    h=msgbox('Running code to Arduino...'); % Send the character
end
% starting from the path start and going until target path, calculates
% distance and then assigns a direction, writing it directly to the
% arduino
for i = size(Optimal_path,1):-1:2
    parent_x = Optimal_path(i,2);
    parent_y = Optimal_path(i,1);
    xval = Optimal_path((i-1), 2);
    yval = Optimal_path((i-1), 1);
    LR = xval - parent_x;
    UD = yval - parent_y;
    if (LR == 0 && UD == -1)
        dir = 'N';
    elseif (LR == 0 && UD == 1)
        dir = 'S';
    elseif (LR == -1 && UD == 0)
        dir = 'W';
    elseif (LR == 1 && UD == 0)
        dir = 'E';
    elseif (LR == -1 && UD == -1)
        dir = 'A';
    elseif (LR == 1 && UD == -1)
        dir = 'B';
    elseif (LR == 1 && UD == 1)
        dir = 'C';
    elseif (LR == -1 && UD == 1)
        dir = 'D';
    end
    directions(j) = dir; % array used to keep track/check validity
    j = j + 1;
    if ARD_ON == 1
        if YTRACES == 7
            for k = 1:15
                write(arduino1, dir, 'char');
                flush(arduino1);
            end
        end
        write(arduino1, dir, 'char'); % Send the character
        flush(arduino1);
    end
    pause(.4);
end

% For the final character, send an 'F' and attempt to read an arduino
% character

if ARD_ON == 1 
    write(arduino1, 'F', 'char');
    flush(arduino1);
    pause(2);
    % Read data from the Arduino
    data = readline(arduino1); % Read the response from Arduino
    disp(data)
    
    % Clean up
    clear arduino1;
end
if ARD_ON == 1
    delete(h);
    h = msgbox('Done.');
    pause(2);
    delete(h);
end

function dist = distance(x1,y1,x2,y2)
%This function calculates the distance between any two cartesian 
%coordinates.
%   Copyright 2009-2010 The MathWorks, Inc.
dist=sqrt((x1-x2)^2 + (y1-y2)^2);
end

function exp_array=expand_array(node_x,node_y,hn,xTarget,yTarget,closed,MAX_X,MAX_Y)
    %Function to return an expanded array
    %This function takes a node and returns the expanded list
    %of successors,with the calculated fn values.
    %The criteria being none of the successors are on the CLOSED list.
    %
    %   Copyright 2009-2010 The MathWorks, Inc.
    
    exp_array=[];
    exp_count=1;
    c2=size(closed,1);%Number of elements in CLOSED including the zeros
    for k= 1:-1:-1
        for j= 1:-1:-1
            if (k~=j || k~=0)  %The node itself is not its successor

                % Include for 4-way connnectivity
                % if abs(k) == 1 && abs(j) == 1
                % continue;
                % end

                s_x = node_x+k;
                s_y = node_y+j;
                if( (s_x >0 && s_x <=MAX_X) && (s_y >0 && s_y <=MAX_Y))%node within array bound
                    flag=1;                    
                    for c1=1:c2
                        if(s_x == closed(c1,1) && s_y == closed(c1,2))
                            flag=0;
                        end 
                    end %End of for loop to check if a successor is on closed list.
                    if (flag == 1)
                        exp_array(exp_count,1) = s_x;
                        exp_array(exp_count,2) = s_y;
                        exp_array(exp_count,3) = hn+distance(node_x,node_y,s_x,s_y);%cost of travelling to node
                        exp_array(exp_count,4) = distance(xTarget,yTarget,s_x,s_y);%distance between node and goal
                        exp_array(exp_count,5) = exp_array(exp_count,3)+exp_array(exp_count,4);%fn
                        exp_count=exp_count+1;
                    end%Populate the exp_array list!!!
                end% End of node within array bound
            end%End of if node is not its own successor loop
        end%End of j for loop
    end%End of k for loop    
end

function new_row = insert_open(xval,yval,parent_xval,parent_yval,hn,gn,fn)
%Function to Populate the OPEN LIST
%OPEN LIST FORMAT
%--------------------------------------------------------------------------
%IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
%-------------------------------------------------------------------------
%
%   Copyright 2009-2010 The MathWorks, Inc.
new_row=[1,8];
new_row(1,1)=1;
new_row(1,2)=xval;
new_row(1,3)=yval;
new_row(1,4)=parent_xval;
new_row(1,5)=parent_yval;
new_row(1,6)=hn;
new_row(1,7)=gn;
new_row(1,8)=fn;
end

function i_min = min_fn(open,OPEN_COUNT,xTarget,yTarget)
%Function to return the Node with minimum fn
% This function takes the list OPEN as its input and returns the index of the
% node that has the least cost
%
%   Copyright 2009-2010 The MathWorks, Inc.
 temp_array=[];
 k=1;
 flag=0;
 goal_index=0;
 for j=1:OPEN_COUNT
     if (open(j,1)==1)
         temp_array(k,:)=[open(j,:) j]; 
         if (open(j,2)==xTarget && open(j,3)==yTarget)
             flag=1;
             goal_index=j;% Store the index of the goal node
         end
         k=k+1;
     end
 end % Get all nodes that are on the list open
 if flag == 1 % one of the successors is the goal node so send this node
     i_min=goal_index;
 end
 % Send the index of the smallest node
 if size(temp_array ~= 0)
  [min_fn,temp_min]=min(temp_array(:,8));% Index of the smallest node in temp array
  i_min=temp_array(temp_min,9);% Index of the smallest node in the OPEN array
 else
     i_min=-1;%The temp_array is empty i.e No more paths are available.
 end
end

function n_index = node_index(OPEN,xval,yval)
    %This function returns the index of the location of a node in the list
    %OPEN
    %
    %   Copyright 2009-2010 The MathWorks, Inc.
    i=1;
    while(OPEN(i,2) ~= xval || OPEN(i,3) ~= yval )
        i=i+1;
    end
    n_index=i;
end
